# Code Generated by Sidekick is for learning and experimentation purposes only.
name: Power Automate repository_dispatch test

on:
  repository_dispatch:
    types: [pa_test]

env:
  EXPORT_FOLDER: ./exported
  MANAGED_FOLDER: ./exported/managed
  UNMANAGED_FOLDER: ./exported/unmanaged
  UNPACKED_FOLDER: ./exported/unpacked

permissions:
  contents: read
  issues: write

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      
      ISSUE_NUMBER: ${{ github.event.client_payload.issueNumber }}
      
      # SPN (Service Principal) secrets
      AZURE_TENANT_ID: ${{ secrets.PP_TENANT_ID }}
      AZURE_CLIENT_ID: ${{ secrets.PP_CLIENT_ID }}
      AZURE_CLIENT_SECRET: ${{ secrets.PP_CLIENT_SECRET }}

      # From repository_dispatch payload
      DEV_ENV_URL: ${{ github.event.client_payload.sourceEnvUrl }}
      TEST_ENV_URL: ${{ github.event.client_payload.targetEnvUrl }}
      SOLUTION_NAME: ${{ github.event.client_payload.solutionName }}
      MANAGED: ${{ github.event.client_payload.managed }}

      # Derived
      SOLUTION_ZIP_NAME: ${{ github.event.client_payload.solutionName }}.zip

    steps:
      - name: Mark tracking issue inprogress
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = Number(process.env.ISSUE_NUMBER);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            console.log(`Repo: ${owner}/${repo}`);
            console.log(`Issue: ${issue_number}`);

            if (!issue_number) {
              core.setFailed("client_payload.issueNumber is missing (ISSUE_NUMBER empty).");
              return;
            }

            await github.rest.issues.removeLabel({ owner, repo, issue_number, name: "completed" }).catch(() => {});
            await github.rest.issues.removeLabel({ owner, repo, issue_number, name: "failed" }).catch(() => {});
            await github.rest.issues.addLabels({ owner, repo, issue_number, labels: ["Inprogress"] });

    
      - name: Checkout
        uses: actions/checkout@v5

      - name: Install Power Platform CLI
        uses: microsoft/powerplatform-actions/actions-install@v1

      - name: Show dispatch payload (debug)
        run: |
          echo "event action/type: ${{ github.event.action }}"
          echo "sourceEnvUrl:  ${{ github.event.client_payload.sourceEnvUrl }}"
          echo "targetEnvUrl:  ${{ github.event.client_payload.targetEnvUrl }}"
          echo "solutionName:  ${{ github.event.client_payload.solutionName }}"
          echo "managed:       ${{ github.event.client_payload.managed }}"
          echo "payload json:  ${{ toJson(github.event.client_payload) }}"

      - name: Ensure folders
        run: |
          mkdir -p "${{ env.EXPORT_FOLDER }}" \
                   "${{ env.MANAGED_FOLDER }}" \
                   "${{ env.UNMANAGED_FOLDER }}" \
                   "${{ env.UNPACKED_FOLDER }}"

      - name: Export unmanaged solution from DEV
        uses: microsoft/powerplatform-actions/export-solution@v1
        with:
          environment-url: ${{ env.DEV_ENV_URL }}
          app-id: ${{ env.AZURE_CLIENT_ID }}
          client-secret: ${{ env.AZURE_CLIENT_SECRET }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          solution-name: ${{ env.SOLUTION_NAME }}
          solution-output-file: ${{ env.UNMANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}
          managed: false

      - name: Export managed solution from DEV
        uses: microsoft/powerplatform-actions/export-solution@v1
        with:
          environment-url: ${{ env.DEV_ENV_URL }}
          app-id: ${{ env.AZURE_CLIENT_ID }}
          client-secret: ${{ env.AZURE_CLIENT_SECRET }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          solution-name: ${{ env.SOLUTION_NAME }}
          solution-output-file: ${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}
          managed: true

      - name: Unpack solution
        run: |
          "$POWERPLATFORMTOOLS_PACPATH" solution unpack \
            --zipfile "${{ env.UNMANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}" \
            --folder "${{ env.UNPACKED_FOLDER }}" \
            --allowDelete
          echo "====== [FULL DIRECTORY TREE OF UNPACKED SOLUTION] ======"
          find "${{ env.UNPACKED_FOLDER }}" -print
          echo ""

      - name: Show all files and content under Workflows
        run: |
          WORKFLOW_DIR="${{ env.UNPACKED_FOLDER }}/Workflows"
          echo "====== [FILES IN Workflows] ======"
          if [ -d "$WORKFLOW_DIR" ]; then
            ls -lh "$WORKFLOW_DIR"

            echo "====== [ALL CONTENT OF .json FILES IN Workflows] ======"
            for f in "$WORKFLOW_DIR"/*.json; do
              [ -f "$f" ] && (echo -e "\n--- FILE: $f ---\n"; cat "$f"; echo "")
            done

            echo "====== [ALL CONTENT OF .xml FILES IN Workflows] ======"
            for f in "$WORKFLOW_DIR"/*.xml; do
              [ -f "$f" ] && (echo -e "\n--- FILE: $f ---\n"; cat "$f"; echo "")
            done
          else
            echo "(No Workflows folder)"
          fi

      - name: Show all other folders/files in unpacked
        run: |
          echo "====== [OTHER FOLDERS AND FILES IN UNPACKED] ======"
          UNPACKED_DIR="${{ env.UNPACKED_FOLDER }}"

          for d in "$UNPACKED_DIR"/*; do
            if [ -d "$d" ] && [ "$d" != "$UNPACKED_DIR/Workflows" ]; then
              echo "[DIR:] $d"
              ls -lh "$d"

              shopt -s nullglob
              files=("$d"/*)
              for f in "${files[@]}"; do
                if [ -f "$f" ]; then
                  echo "- $f"
                  cat "$f"
                  echo ""
                fi
              done
              shopt -u nullglob
            fi
          done

          exit 0

      - name: Create deployment settings
        run: |
          echo "Creating deployment settings JSON from managed solution..."
          "$POWERPLATFORMTOOLS_PACPATH" solution create-settings \
            --solution-zip "${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}" \
            --settings-file "${{ env.MANAGED_FOLDER }}/settings.json"

      - name: Display settings.json contents
        run: |
          echo "Printing the whole setting file..."
          if [ -f "${{ env.MANAGED_FOLDER }}/settings.json" ]; then
            cat "${{ env.MANAGED_FOLDER }}/settings.json"
          else
            echo "(settings.json not found)"
          fi

      - name: Extract FLOW connection references
        run: |
          WORKFLOW_DIR="${{ env.UNPACKED_FOLDER }}/Workflows"
          OUTPUT="flow-connection-refs.txt"
          if [ -d "$WORKFLOW_DIR" ]; then
            jq -r '
              .properties.connectionReferences // {} |
              to_entries[] |
              .value.connection.connectionReferenceLogicalName // empty
            ' "$WORKFLOW_DIR"/*.json | sort -u > "$OUTPUT"
          else
            : > "$OUTPUT"
          fi
          echo "FLOW connection references (LogicalNames):"
          cat "$OUTPUT"

      - name: Authenticate to TEST
        run: |
          "$POWERPLATFORMTOOLS_PACPATH" auth create \
            --name test \
            --applicationId "${{ env.AZURE_CLIENT_ID }}" \
            --clientSecret "${{ env.AZURE_CLIENT_SECRET }}" \
            --tenant "${{ env.AZURE_TENANT_ID }}" \
            --environment "${{ env.TEST_ENV_URL }}" \
            --accept-cleartext-caching

          "$POWERPLATFORMTOOLS_PACPATH" auth select --name test

      - name: Patch ONLY flow connection refs
        run: |
          set -euo pipefail

          WORKFLOW_DIR="./exported/unpacked/Workflows"
          SETTINGS_FILE="./exported/managed/settings.json"
          TEST_ENV_URL="${{ env.TEST_ENV_URL }}"
          PAC="$POWERPLATFORMTOOLS_PACPATH"

          FLOW_CONN_REFS="flow-connection-refs.txt"
          if [ -d "$WORKFLOW_DIR" ]; then
            jq -r '
              .properties.connectionReferences // {} |
              to_entries[] |
              .value.connection.connectionReferenceLogicalName // empty
            ' "$WORKFLOW_DIR"/*.json | sort -u > "$FLOW_CONN_REFS"
          else
            : > "$FLOW_CONN_REFS"
          fi

          echo "Flow logical names to patch:"
          cat "$FLOW_CONN_REFS"

          CONN_LIST_OUT="test-connections.txt"
          $PAC connection list --environment "$TEST_ENV_URL" > "$CONN_LIST_OUT"

          TMP="$SETTINGS_FILE.tmp"
          cp "$SETTINGS_FILE" "$TMP"

          while read -r FLOW_LOGICAL; do
            [ -z "$FLOW_LOGICAL" ] && continue
            echo "Processing flow logical: $FLOW_LOGICAL"

            IDX=$(jq -r --arg r "$FLOW_LOGICAL" '
              .ConnectionReferences | to_entries[]
              | select(.value.LogicalName==$r) | .key' "$SETTINGS_FILE")

            [ -z "$IDX" ] && { echo "  Not found in settings.json, skipping."; continue; }

            CONNECTOR_ID=$(jq -r --argjson i "$IDX" '.ConnectionReferences[$i].ConnectorId' "$SETTINGS_FILE")

            MATCH_LINE=$(grep -i "$CONNECTOR_ID" "$CONN_LIST_OUT" | head -n1 || true)
            FOUND_CONN_ID=$(echo "$MATCH_LINE" | awk '{print $1}' | tr -d '[:space:]' | tr -d '\r' || true)

            if [ -n "$FOUND_CONN_ID" ]; then
              echo "  Found connection id: $FOUND_CONN_ID"
              jq --arg id "$FOUND_CONN_ID" --argjson i "$IDX" \
                '.ConnectionReferences[$i].ConnectionId = $id' "$TMP" > "${TMP}.2" && mv "${TMP}.2" "$TMP"
            else
              echo "  WARNING: No matching connection id found. Will remain blank."
            fi
          done < "$FLOW_CONN_REFS"

          mv "$TMP" "$SETTINGS_FILE"
          echo "Patched settings file:"
          cat "$SETTINGS_FILE"

      - name: Import solution using pac CLI (managed flag from payload)
        run: |
          "$POWERPLATFORMTOOLS_PACPATH" auth create \
            --applicationId "${{ env.AZURE_CLIENT_ID }}" \
            --clientSecret "${{ env.AZURE_CLIENT_SECRET }}" \
            --tenant "${{ env.AZURE_TENANT_ID }}" \
            --environment "${{ env.TEST_ENV_URL }}"

          # Supports boolean true/false OR string "true"/"false"
          MANAGED_RAW="${{ env.MANAGED }}"
          if [[ "$MANAGED_RAW" == "true" || "$MANAGED_RAW" == "True" || "$MANAGED_RAW" == "TRUE" ]]; then
            SOL_PATH="${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}"
          else
            SOL_PATH="${{ env.UNMANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}"
          fi

          "$POWERPLATFORMTOOLS_PACPATH" solution import \
            --path "$SOL_PATH" \
            --settings-file "${{ env.MANAGED_FOLDER }}/settings.json" \
            --force-overwrite


      - name: Mark tracking issue completed
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = Number(process.env.ISSUE_NUMBER);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            console.log(`Repo: ${owner}/${repo}`);
            console.log(`Issue: ${issue_number}`);
            
            if (!issue_number) return;

            await github.rest.issues.removeLabel({ owner, repo, issue_number, name: "inprogress" }).catch(() => {});
            await github.rest.issues.addLabels({ owner, repo, issue_number, labels: ["Completed"] });
            await github.rest.issues.update({ owner, repo, issue_number, state: "closed" });
            await github.rest.issues.createComment({ owner, repo, issue_number, body: "Hurray, the Deployment completed successfully."});

      - name: Mark tracking issue failed
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = Number(process.env.ISSUE_NUMBER);
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            console.log(`Repo: ${owner}/${repo}`);
            console.log(`Issue: ${issue_number}`);

            if (!issue_number) return;

            await github.rest.issues.removeLabel({ owner, repo, issue_number, name: "inprogress" }).catch(() => {});
            await github.rest.issues.addLabels({ owner, repo, issue_number, labels: ["Failed"] });
            await github.rest.issues.createComment({ owner, repo, issue_number, body: "Sorry, the deployment is Failed" });
            
            const assignees = ["Smadavaram-Kumar"]; 
            await github.rest.issues.addAssignees({owner, repo, issue_number,assignees });
