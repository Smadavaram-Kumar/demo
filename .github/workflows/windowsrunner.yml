name: deploy setting workflow using windows runner

run-name: deploy_setting

on:
  workflow_dispatch:
    inputs:
      solution_name:
        description: 'Solution unique name (not display name).'
        required: true

env:
  # Azure AD / Service Principal (store as repo secrets)
  AZURE_TENANT_ID: ${{ secrets.PP_TENANT_ID }}
  AZURE_CLIENT_ID: ${{ secrets.PP_CLIENT_ID }}
  AZURE_CLIENT_SECRET: ${{ secrets.PP_CLIENT_SECRET }}

  # Environments (store as repo secrets)
  DEV_ENV_URL: 'https://org23b23f97.crm.dynamics.com'
  TEST_ENV_URL: 'https://orgd93932c9.crm.dynamics.com'

  # Local folder structure on the runner
  EXPORT_FOLDER: .\exported
  DEPLOY_FOLDER: .\deploy
  SOLUTION_FOLDER: .\exported\solutions
  MANAGED_FOLDER: .\exported\managed
  UNPACKED_FOLDER: .\exported\unpacked

  # Output zip filename
  SOLUTION_ZIP_NAME: ${{ github.event.inputs.solution_name }}.managed.zip

jobs:
  first-job:
    runs-on: windows-latest

    steps:

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        lfs: true

    - name: Ensure folders exist
      run: |
        Write-Host "Creating folder structure on runner..."
        New-Item -ItemType Directory -Force -Path "${env:EXPORT_FOLDER}" | Out-Null
        New-Item -ItemType Directory -Force -Path "${env:MANAGED_FOLDER}" | Out-Null
        New-Item -ItemType Directory -Force -Path "${env:UNPACKED_FOLDER}" | Out-Null
        New-Item -ItemType Directory -Force -Path "${env:DEPLOY_FOLDER}" | Out-Null
        Get-ChildItem -Recurse

    - name: Install Power Platform CLI / Tools
      uses: microsoft/powerplatform-actions/actions-install@v1

    # -----------------------
    # EXPORT (Dev) -> Managed ZIP
    # -----------------------
    - name: Export managed solution from Dev
      uses: microsoft/powerplatform-actions/export-solution@v1
      with:
        environment-url: ${{ env.DEV_ENV_URL }}
        app-id: ${{ env.AZURE_CLIENT_ID }}
        client-secret: ${{ env.AZURE_CLIENT_SECRET }}
        tenant-id: ${{ env.AZURE_TENANT_ID }}
        solution-name: ${{ github.event.inputs.solution_name }}
        solution-output-file: ${{ env.MANAGED_FOLDER }}\${{ env.SOLUTION_ZIP_NAME }}
        managed: true

    - name: List exported managed package
      run: |
        Write-Host "Listing managed folder contents:"
        Get-ChildItem "${env:MANAGED_FOLDER}"
        Write-Host "Path used for solution zip: ${env:MANAGED_FOLDER}\${env:SOLUTION_ZIP_NAME}"

    - name: Generate deployment settings file for solution
      run: |
        Write-Host "Creating deployment settings JSON from managed solution..."
        & "${env:POWERPLATFORMTOOLS_PACPATH}" solution create-settings --solution-zip "${env:MANAGED_FOLDER}\${env:SOLUTION_ZIP_NAME}" --settings-file "${env:MANAGED_FOLDER}\settings.json"
      shell: pwsh


    - name: Display settings.json contents
      run: Get-Content "${env:MANAGED_FOLDER}\settings.json"

#i am trying this methods, as it can resolve authorization problem.
#user created connection, then only user can see - user can PAC CLI
#admin can see all connections every user created using power shell tool
#SPN need permissions to see/read the connections in the dataverse.
#GitHub-hosted runners (and many CI/CD environments) don’t have a desktop UI, so pop-up dialogs (like the login window) can’t appear.
#Github is headless env i.e non interactive env.
#admin powersgell
#    - name: List Connections Using Admin PowerShell (Interactive)
#      shell: pwsh
#      run: |
#        Write-Host "Installing Power Apps admin PowerShell module and listing connections (requires user login)..."
#        Install-Module Microsoft.PowerApps.Administration.PowerShell -Force -Scope CurrentUser
#        Import-Module Microsoft.PowerApps.Administration.PowerShell
#        Add-PowerAppsAccount
#        Get-AdminPowerAppConnection -EnvironmentName "Test_for_demo" | Format-Table Id,Name,ConnectorId,Status -AutoSize



#way1
    # Authenticate and list connections in DEV for testing 
#    - name: Authenticate to DEV environment
#      run: |
#        Write-Host "Authenticating pac to DEV environment..."

          # Code Generated by Sidekick is for learning and experimentation purposes only.
#        & "${env:POWERPLATFORMTOOLS_PACPATH}" auth create --url "${env:DEV_ENV_URL}"

#        # List connections accessible to your user in this environment:
#        & "${env:POWERPLATFORMTOOLS_PACPATH}" connection list --environment "${env:DEV_ENV_URL}"
#      shell: pwsh

    - name: Authenticate to TEST environment and List Connections (headless)
      run: |

        # --- BEGIN: Direct Dataverse Web API authentication with Service Principal (headless mode)
        Write-Host "Listing connections using headless Dataverse Web API call..."

        # Code Generated by Sidekick is for learning and experimentation purposes only.
        # --- BEGIN: Direct Dataverse Web API authentication with Service Principal (headless mode)
        Write-Host "Listing connections using headless Dataverse Web API call..."
        
        # Set variables from environment
        $TENANT_ID = "${env:AZURE_TENANT_ID}"
        $CLIENT_ID = "${env:AZURE_CLIENT_ID}"
        $CLIENT_SECRET = "${env:AZURE_CLIENT_SECRET}"
        $ORG_URL = "${env:TEST_ENV_URL}"
        
        # Prepare token body
        $body = @{
          client_id     = $CLIENT_ID
          client_secret = $CLIENT_SECRET
          scope         = "$ORG_URL/.default"
          grant_type    = "client_credentials"
        }
        
        # Get the access token FIRST
        $tokenResponse = Invoke-RestMethod -Method Post -Uri "https://login.microsoftonline.com/$TENANT_ID/oauth2/v2.0/token" `
          -ContentType "application/x-www-form-urlencoded" -Body $body
        
        $accessToken = $tokenResponse.access_token
        
        Write-Host "Access Token starts with: $($accessToken.Substring(0,10))..." # Safe to show only part
        Write-Host "API Url: $ORG_URL/api/data/v9.2/connections?`$select=connectionid,name,description,statuscode,ownerid&`$top=500"
        
        # Make the API call
        try {
            $response = Invoke-RestMethod -Method Get -Uri "$ORG_URL/api/data/v9.2/connections?`$select=connectionid,name,description,statuscode,ownerid&`$top=500" `
                -Headers @{Authorization = "Bearer $accessToken"; Accept = "application/json"}
            Write-Host "Raw API Response:"
            Write-Host ($response | ConvertTo-Json -Depth 5)
        
            if ($response.value) {
                Write-Host "Connections as raw JSON:"
                $response.value | ConvertTo-Json -Depth 4
                Write-Host "Connections as table:"
                $response.value | Format-Table connectionid, name, statuscode, ownerid | Out-String | Write-Host
            } else {
                Write-Host "No connection records returned."
            }
        } catch {
            Write-Host "API call failed: $($_.Exception.Message)"
            if ($_.Exception.Response -ne $null) {
                $reader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                Write-Host "API Error Body:" 
                Write-Host $reader.ReadToEnd()
            }
        }
        
        # --- END: Direct API headless call




        
        # --- END: Direct API headless call
      shell: pwsh

#way2
    # Authenticate and list connections in TEST for testing
    - name: Authenticate to TEST environment
      run: |
        Write-Host "Authenticating pac to TEST environment..."
        
        & "${env:POWERPLATFORMTOOLS_PACPATH}" auth create --name "ci-test-spn" `
          --applicationId "${env:AZURE_CLIENT_ID}" `
          --clientSecret "${env:AZURE_CLIENT_SECRET}" `
          --tenant "${env:AZURE_TENANT_ID}" `
          --environment "${env:TEST_ENV_URL}" `
          --accept-cleartext-caching


        & "${env:POWERPLATFORMTOOLS_PACPATH}" auth list
        & "${env:POWERPLATFORMTOOLS_PACPATH}" auth select --name "ci-test-spn"

        Write-Host "Listing all connections in TEST environment..."
        & "${env:POWERPLATFORMTOOLS_PACPATH}" connection list --environment "${env:TEST_ENV_URL}"
      shell: pwsh

   

