name: deploy setting workflow

run-name: deploy_setting


on:
  workflow_dispatch:
    inputs:
      solution_name:
        description: 'Solution unique name (not display name).'
        required: true

env:
  # Azure AD / Service Principal (store as repo secrets)
  AZURE_TENANT_ID: ${{ secrets.PP_TENANT_ID }}
  AZURE_CLIENT_ID: ${{ secrets.PP_CLIENT_ID }}
  AZURE_CLIENT_SECRET: ${{ secrets.PP_CLIENT_SECRET }}

  # Environments (store as repo secrets)
  DEV_ENV_URL: 'https://org23b23f97.crm.dynamics.com'     # e.g. https://org-<id>.crm.dynamics.com
  TEST_ENV_URL: 'https://orgd93932c9.crm.dynamics.com'

  # Local folder structure on the runner (you can change these)
  EXPORT_FOLDER: ./exported                 # where CLI writes the exported zip(s)
  DEPLOY_FOLDER: ./deploy                   # staging folder used before import
  SOLUTION_FOLDER: ./exported/solutions     # generic solution folder path
  MANAGED_FOLDER: ./exported/managed        # store managed zip here
  UNPACKED_FOLDER: ./exported/unpacked     # unpacked folder (if using pac unpack or unzip)

  # Output zip filename (will use solution_name input + suffix)
  SOLUTION_ZIP_NAME: ${{ github.event.inputs.solution_name }}.managed.zip


jobs:
  first-job:
    runs-on: ubuntu-latest

    steps:
    
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        lfs: true

    - name: Ensure folders exist
      run: |
        echo "Creating folder structure on runner..."
        mkdir -p "${{ env.EXPORT_FOLDER }}" "${{ env.MANAGED_FOLDER }}" "${{ env.UNPACKED_FOLDER }}" "${{ env.DEPLOY_FOLDER }}"
        ls -la

    - name: Install Power Platform CLI / Tools
      # installs the pac wrapper and related tooling used by the export/import actions
      uses: microsoft/powerplatform-actions/actions-install@v1


    #- name: Create output directory
    #  run: mkdir -p out
      
    # -----------------------
    # EXPORT (Dev) -> Managed ZIP
    # -----------------------
    - name: Export managed solution from Dev
      uses: microsoft/powerplatform-actions/export-solution@v1
      with:
        environment-url: ${{ env.DEV_ENV_URL }}
        app-id: ${{ env.AZURE_CLIENT_ID }}
        client-secret: ${{ env.AZURE_CLIENT_SECRET }}
        tenant-id: ${{ env.AZURE_TENANT_ID }}
        solution-name: ${{ github.event.inputs.solution_name }}
        solution-output-file: ${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}
        managed: true

    - name: List exported managed package
      run: |
        echo "Listing managed folder contents:"
        ls -la "${{ env.MANAGED_FOLDER }}" || true
        echo "Path used for solution zip: ${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}"


    - name: Generate deployment settings file for solution
      run: |
        echo "Creating deployment settings JSON from managed solution..."
        "$POWERPLATFORMTOOLS_PACPATH" solution create-settings \
          --solution-zip "${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}" \
          --settings-file "${{ env.MANAGED_FOLDER }}/settings.json"


    - name: Display settings.json contents
      run: cat ${{ env.MANAGED_FOLDER }}/settings.json


    #- name: Install jq for JSON processing
    #  run: |
    #    sudo apt-get update
    #    sudo apt-get install -y jq

    #- name: Check Power Platform CLI version supports JSON output
    #  run: |
    #    RAW_VERSION=$("$POWERPLATFORMTOOLS_PACPATH" --version)
    #    echo "Power Platform CLI raw version: $RAW_VERSION"
     #   CLI_VERSION=$(echo "$RAW_VERSION" | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+')
     #   echo "Power Platform CLI parsed version: $CLI_VERSION"
     #   REQUIRED_VERSION="1.10.4"
     #   if [ "$(printf '%s\n' "$REQUIRED_VERSION" "$CLI_VERSION" | sort -V | head -n1)" != "$REQUIRED_VERSION" ]; then
     #     echo "ERROR: Power Platform CLI version must be at least $REQUIRED_VERSION for JSON output support."
     #     exit 1
     #   fi

   # - name: Authenticate pac to TEST environment
    #  run: |
    #    "$POWERPLATFORMTOOLS_PACPATH" auth create --name "ci-test-spn" \
    #      --applicationId "${{ env.AZURE_CLIENT_ID }}" \
    #      --clientSecret "${{ env.AZURE_CLIENT_SECRET }}" \
    #      --tenant "${{ env.AZURE_TENANT_ID }}" \
    #      --environment "${{ env.TEST_ENV_URL }}" \
    #      --accept-cleartext-caching
    #    "$POWERPLATFORMTOOLS_PACPATH" auth select --name "ci-test-spn" || true

   # - name: Retrieve connections as JSON from TEST environment
   #   run: |
   #     CONNECTIONS_JSON=$("$POWERPLATFORMTOOLS_PACPATH" connection list \
   #       --environment "${{ env.TEST_ENV_URL }}" \
   #       --output json)
   #     echo "$CONNECTIONS_JSON" > connections.json

#    - name: Extract and display only connectionId values
#      run: |
#        cat connections.json | jq -r '.[].connectionId'



    # --- after your existing steps that generate settings.json ---
    - name: Authenticate to target (TEST) environment
      run: |
        echo "Authenticating pac to TEST environment..."
        "$POWERPLATFORMTOOLS_PACPATH" auth create --name "ci-test-spn" \
          --applicationId "${{ env.AZURE_CLIENT_ID }}" \
          --clientSecret "${{ env.AZURE_CLIENT_SECRET }}" \
          --tenant "${{ env.AZURE_TENANT_ID }}" \
          --environment "${{ env.TEST_ENV_URL }}"\
          --accept-cleartext-caching
  
        # select the auth profile (optional, ensures subsequent pac commands target TEST)
        "$POWERPLATFORMTOOLS_PACPATH" auth list
        "$POWERPLATFORMTOOLS_PACPATH" auth select --name "ci-test-spn" || true


         echo "Listing all connections in TEST environment..."
        "$POWERPLATFORMTOOLS_PACPATH" connection list --environment "${{ env.TEST_ENV_URL }}"


#    - name: List all connections (as JSON) in TEST environment
#      run: |
#        echo "Getting all connections in TEST..."
#        "$POWERPLATFORMTOOLS_PACPATH" connection list --environment "${{ env.TEST_ENV_URL }}" --output json > exported/managed/test-connections.json
#        cat exported/managed/test-connections.json
  
    - name: Query connection IDs from target environment and patch settings.json
      shell: bash
      run: |
        set -euo pipefail
        MANAGED_FOLDER="${{ env.MANAGED_FOLDER }}"
        SETTINGS_FILE="$MANAGED_FOLDER/settings.json"
        SOLUTION_ZIP="$MANAGED_FOLDER/${{ env.SOLUTION_ZIP_NAME }}"
  
        echo "Settings before patch:"
        cat "$SETTINGS_FILE" || true
  
        # Install jq (runners usually have it but this ensures availability)
        if ! command -v jq >/dev/null 2>&1; then
          echo "Installing jq..."
          sudo apt-get update && sudo apt-get install -y jq
        fi
  
        # Loop through each ConnectionReferences entry in the settings.json and try to find
        # a matching connection in the target environment. We will match by ConnectorId substring
        # (e.g. '/providers/Microsoft.PowerApps/apis/shared_gmail' -> 'shared_gmail').
        # This script is generic: for each reference we perfom a pac connection list and look for the connector name.
  
        TMP="$MANAGED_FOLDER/settings.tmp.json"
        cp "$SETTINGS_FILE" "$TMP"
  
        # iterate references
        refs_count=$(jq '.ConnectionReferences | length' "$SETTINGS_FILE")
        echo "Found $refs_count connection reference(s) in settings.json."
  
        for i in $(seq 0 $((refs_count - 1))); do
          connectorId=$(jq -r ".ConnectionReferences[$i].ConnectorId" "$SETTINGS_FILE")
          echo "$connectorId"
          logicalName=$(jq -r ".ConnectionReferences[$i].LogicalName" "$SETTINGS_FILE")
          echo "$logicalName"
          echo "Processing logicalName=$logicalName connectorId=$connectorId"
  
          # derive a short connector token (e.g. shared_gmail from '/providers/.../shared_gmail')
          connector_token=$(basename "$connectorId")
          echo "Searching for connection in target env for connector token: $connector_token"
  
          # Get connection list from pac (the output is table-like; we parse it)
          # If your pac supports json output, replace below with the json flag.
          #conn_list=$("$POWERPLATFORMTOOLS_PACPATH" connection list --environment "${{ env.TEST_ENV_URL }}" 2>/dev/null || true)

          conn_list=$("$POWERPLATFORMTOOLS_PACPATH" connection list --environment "${TEST_ENV_URL}" 2>/dev/null || true)
          echo "==== PAC connection list output for debug ===="
          echo "$conn_list"
          echo "==== End PAC connection list output ===="
          
          found_conn_id=$(echo "$conn_list" \
            | grep "$connectorId" \
            | awk '{print $1}' \
            | grep -Eo '^[0-9a-fA-F-]{36}$' \
            | head -n1 || true)

          
          echo "found_conn_id: '$found_conn_id'"

  
          # Fallback: try pac connection show if you know the connection name pattern (not always applicable)
          if [ -z "$found_conn_id" ]; then
            echo "No connection id found by token. Trying pac connection show with connector token fallback..."
            # This is a best-effort extra step. Depending on your naming conventions you may attempt
            # "$POWERPLATFORMTOOLS_PACPATH" connection show --name "<expected-conn-name>"
            found_conn_id=""
          fi
  
          if [ -n "$found_conn_id" ]; then
            echo "Found connection id for $logicalName -> $found_conn_id. Patching settings.json..."
            # Update settings.tmp.json: set .ConnectionReferences[i].ConnectionId = found_conn_id
            jq --arg id "$found_conn_id" --argjson idx "$i" \
               '.ConnectionReferences[$idx].ConnectionId = $id' "$TMP" > "${TMP}.2" && mv "${TMP}.2" "$TMP"
          else
            echo "WARNING: could not find connection id for connector '$connector_token' in target environment."
            echo "You may need to create the connection in the target environment, or update the script to match your naming."
          fi
        done
  
        # finalize patched settings.json
        mv "$TMP" "$SETTINGS_FILE"
        echo "Settings after patch:"
        cat "$SETTINGS_FILE"


    
