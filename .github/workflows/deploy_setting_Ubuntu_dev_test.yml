name: deploy setting workflow- dev to test

run-name: deploy_setting


on:
  workflow_dispatch:
    inputs:
      solution_name:
        description: 'Solution unique name (not display name).'
        required: true

env:
  # Azure AD / Service Principal (store as repo secrets)
  AZURE_TENANT_ID: ${{ secrets.PP_TENANT_ID }}
  AZURE_CLIENT_ID: ${{ secrets.PP_CLIENT_ID }}
  AZURE_CLIENT_SECRET: ${{ secrets.PP_CLIENT_SECRET }}

  # Environments (store as repo secrets)
  DEV_ENV_URL: 'https://org23b23f97.crm.dynamics.com'     # e.g. https://org-<id>.crm.dynamics.com
  TEST_ENV_URL: 'https://orgd93932c9.crm.dynamics.com'

  # Local folder structure on the runner (you can change these)
  EXPORT_FOLDER: ./exported                 # where CLI writes the exported zip(s)
  DEPLOY_FOLDER: ./deploy                   # staging folder used before import
  SOLUTION_FOLDER: ./exported/solutions     # generic solution folder path
  MANAGED_FOLDER: ./exported/managed        # store managed zip here
  UNPACKED_FOLDER: ./exported/unpacked     # unpacked folder (if using pac unpack or unzip)

  # Output zip filename (will use solution_name input + suffix)
  SOLUTION_ZIP_NAME: ${{ github.event.inputs.solution_name }}.managed.zip


jobs:
  first-job:
    runs-on: ubuntu-latest

    steps:
    
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        lfs: true

    - name: Ensure folders exist
      run: |
        echo "Creating folder structure on runner..."
        mkdir -p "${{ env.EXPORT_FOLDER }}" "${{ env.MANAGED_FOLDER }}" "${{ env.UNPACKED_FOLDER }}" "${{ env.DEPLOY_FOLDER }}"
        ls -la

    - name: Install Power Platform CLI / Tools
      # installs the pac wrapper and related tooling used by the export/import actions
      uses: microsoft/powerplatform-actions/actions-install@v1


    #- name: Create output directory
    #  run: mkdir -p out
      
    # -----------------------
    # EXPORT (Dev) -> Managed ZIP
    # -----------------------
    - name: Export managed solution from Dev
      uses: microsoft/powerplatform-actions/export-solution@v1
      with:
        environment-url: ${{ env.DEV_ENV_URL }}
        app-id: ${{ env.AZURE_CLIENT_ID }}
        client-secret: ${{ env.AZURE_CLIENT_SECRET }}
        tenant-id: ${{ env.AZURE_TENANT_ID }}
        solution-name: ${{ github.event.inputs.solution_name }}
        solution-output-file: ${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}
        managed: true

    - name: List exported managed package
      run: |
        echo "Listing managed folder contents:"
        ls -la "${{ env.MANAGED_FOLDER }}" || true
        echo "Path used for solution zip: ${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}"

    - name: Validate flows do NOT contain hardcoded connections (Place-2 check)
      shell: bash
      run: |
        set -euo pipefail

        ZIP="${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}"
        UNPACK="${{ env.UNPACKED_FOLDER }}"

        echo "Unpacking solution to inspect flow JSON..."
        rm -rf "$UNPACK"
        mkdir -p "$UNPACK"
        unzip -q "$ZIP" -d "$UNPACK"

        echo "Scanning workflows for hidden connectionIds..."
        BAD_FILES=$(grep -R "\"connectionId\"" "$UNPACK/Workflows" || true)

        if [ -n "$BAD_FILES" ]; then
          echo "ERROR: Hardcoded flow-level connections found!"
          echo "These flows contain Place-2 connections:"
          echo "$BAD_FILES"
          echo ""
          echo "Fix required in DEV:"
          echo " - Open the flow"
          echo " - Rebind to Connection Reference"
          echo " - Save"
          echo " - Turn OFF â†’ ON"
          echo " - Re-export solution"
          exit 1
        else
          echo "PASS: No hidden flow-level connections found."
        fi


    - name: Generate deployment settings file for solution
      run: |
        echo "Creating deployment settings JSON from managed solution..."
        "$POWERPLATFORMTOOLS_PACPATH" solution create-settings \
          --solution-zip "${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}" \
          --settings-file "${{ env.MANAGED_FOLDER }}/settings.json"


    - name: Display settings.json contents
      run: cat ${{ env.MANAGED_FOLDER }}/settings.json


    #- name: Install jq for JSON processing
    #  run: |
    #    sudo apt-get update
    #    sudo apt-get install -y jq

    #- name: Check Power Platform CLI version supports JSON output
    #  run: |
    #    RAW_VERSION=$("$POWERPLATFORMTOOLS_PACPATH" --version)
    #    echo "Power Platform CLI raw version: $RAW_VERSION"
     #   CLI_VERSION=$(echo "$RAW_VERSION" | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+')
     #   echo "Power Platform CLI parsed version: $CLI_VERSION"
     #   REQUIRED_VERSION="1.10.4"
     #   if [ "$(printf '%s\n' "$REQUIRED_VERSION" "$CLI_VERSION" | sort -V | head -n1)" != "$REQUIRED_VERSION" ]; then
     #     echo "ERROR: Power Platform CLI version must be at least $REQUIRED_VERSION for JSON output support."
     #     exit 1
     #   fi

   # - name: Authenticate pac to TEST environment
    #  run: |
    #    "$POWERPLATFORMTOOLS_PACPATH" auth create --name "ci-test-spn" \
    #      --applicationId "${{ env.AZURE_CLIENT_ID }}" \
    #      --clientSecret "${{ env.AZURE_CLIENT_SECRET }}" \
    #      --tenant "${{ env.AZURE_TENANT_ID }}" \
    #      --environment "${{ env.TEST_ENV_URL }}" \
    #      --accept-cleartext-caching
    #    "$POWERPLATFORMTOOLS_PACPATH" auth select --name "ci-test-spn" || true

   # - name: Retrieve connections as JSON from TEST environment
   #   run: |
   #     CONNECTIONS_JSON=$("$POWERPLATFORMTOOLS_PACPATH" connection list \
   #       --environment "${{ env.TEST_ENV_URL }}" \
   #       --output json)
   #     echo "$CONNECTIONS_JSON" > connections.json

#    - name: Extract and display only connectionId values
#      run: |
#        cat connections.json | jq -r '.[].connectionId'



    # --- after your existing steps that generate settings.json ---
    - name: Authenticate to target (TEST) environment
      run: |
        echo "Authenticating pac to TEST environment..."
        "$POWERPLATFORMTOOLS_PACPATH" auth create --name "ci-test-spn" \
          --applicationId "${{ env.AZURE_CLIENT_ID }}" \
          --clientSecret "${{ env.AZURE_CLIENT_SECRET }}" \
          --tenant "${{ env.AZURE_TENANT_ID }}" \
          --environment "${{ env.TEST_ENV_URL }}"\
          --accept-cleartext-caching
  
        # select the auth profile (optional, ensures subsequent pac commands target TEST)
        "$POWERPLATFORMTOOLS_PACPATH" auth list
        "$POWERPLATFORMTOOLS_PACPATH" auth select --name "ci-test-spn" || true


         echo "Listing all connections in TEST environment..."
        "$POWERPLATFORMTOOLS_PACPATH" connection list --environment "${{ env.TEST_ENV_URL }}"


#    - name: List all connections (as JSON) in TEST environment
#      run: |
#        echo "Getting all connections in TEST..."
#        "$POWERPLATFORMTOOLS_PACPATH" connection list --environment "${{ env.TEST_ENV_URL }}" --output json > exported/managed/test-connections.json
#        cat exported/managed/test-connections.json
  
    - name: Query connection IDs from target environment and patch settings.json
      shell: bash
      run: |
        set -euo pipefail
        MANAGED_FOLDER="${{ env.MANAGED_FOLDER }}"
        SETTINGS_FILE="$MANAGED_FOLDER/settings.json"
        SOLUTION_ZIP="$MANAGED_FOLDER/${{ env.SOLUTION_ZIP_NAME }}"
  
        echo "Settings before patch:"
        cat "$SETTINGS_FILE" || true
  
        # Install jq (runners usually have it but this ensures availability)
        if ! command -v jq >/dev/null 2>&1; then
          echo "Installing jq..."
          sudo apt-get update && sudo apt-get install -y jq
        fi
  
        # Loop through each ConnectionReferences entry in the settings.json and try to find
        # a matching connection in the target environment. We will match by ConnectorId substring
        # (e.g. '/providers/Microsoft.PowerApps/apis/shared_gmail' -> 'shared_gmail').
        # This script is generic: for each reference we perfom a pac connection list and look for the connector name.
  
        TMP="$MANAGED_FOLDER/settings.tmp.json"
        cp "$SETTINGS_FILE" "$TMP"
  
        # iterate references
        refs_count=$(jq '.ConnectionReferences | length' "$SETTINGS_FILE")
        echo "Found $refs_count connection reference(s) in settings.json."
  
        for i in $(seq 0 $((refs_count - 1))); do
          connectorId=$(jq -r ".ConnectionReferences[$i].ConnectorId" "$SETTINGS_FILE")
          logicalName=$(jq -r ".ConnectionReferences[$i].LogicalName" "$SETTINGS_FILE")

          echo "Processing logicalName=$logicalName connectorId=$connectorId"
  
          # derive a short connector token (e.g. shared_gmail from '/providers/.../shared_gmail')
          connector_token=$(basename "$connectorId")
          echo "Searching for connection in target env for connector token: $connector_token"
  
          # Get connection list from pac (the output is table-like; we parse it)
          # If your pac supports json output, replace below with the json flag.
          #conn_list=$("$POWERPLATFORMTOOLS_PACPATH" connection list --environment "${{ env.TEST_ENV_URL }}" 2>/dev/null || true)

          conn_list=$("$POWERPLATFORMTOOLS_PACPATH" connection list --environment "${TEST_ENV_URL}" 2>/dev/null || true)
          echo "==== PAC connection list output for debug ===="
          echo "$conn_list"
          echo "==== End PAC connection list output ===="


          # find the line containing connectorId (case-insensitive)
          match_line=$(echo "$conn_list" | grep -i "$connectorId" | head -n1 || true)
          echo "Match line: '$match_line'"
          
          # get first whitespace-separated token (the id column - may be just a GUID or a prefix+GUID string)
          first_token=$(echo "$match_line" | awk '{print $1}' | tr -d '[:space:]' | tr -d '\r' || true)
          echo "First token: '$first_token'"
          
          # Default: use first_token as the found connection id (covers both legacy and modern cases)
          found_conn_id="$first_token"
          
          # If you ever must supply JUST the GUID in older environments, you can use this block.
          # Extract a GUID if present within the first_token (uncomment and use if needed)
          # guid_candidate=$(echo "$first_token" | grep -Eo '[0-9a-fA-F]{32}|[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}' | head -n1 || true)
          # if [ -n "$guid_candidate" ]; then
          #   found_conn_id="$guid_candidate"
          # fi
          
          echo "found_conn_id: '$found_conn_id'"

          
          
          # find the line containing connectorId (case-insensitive)
          #match_line=$(echo "$conn_list" | grep -i "$connectorId" || true)
          #echo "Match line: '$match_line'"
          
          # get first whitespace-separated token (the id column)
          #first_token=$(echo "$match_line" | awk '{print $1}' || true)
          #echo "First token: '$first_token'"
          
          # normalize token: remove non-hex/dash characters
          #normalized=$(echo "$first_token" | tr -d '[:space:]' | tr -d '\r' | sed 's/[^0-9a-fA-F-]//g')
          
          # Accept either 32 hex chars (no dashes) or 36 chars with dashes
          #if echo "$normalized" | grep -Eq '^[0-9a-fA-F]{32}$'; then
          #found_conn_id="$normalized"
          #elif echo "$normalized" | grep -Eq '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'; then
          #found_conn_id="$normalized"
          #else
          #found_conn_id=""
          #fi
          
          #echo "found_conn_id: '$found_conn_id'"


  
          # Fallback: try pac connection show if you know the connection name pattern (not always applicable)
          if [ -z "$found_conn_id" ]; then
            echo "No connection id found by token. Trying pac connection show with connector token fallback..."
            # This is a best-effort extra step. Depending on your naming conventions you may attempt
            # "$POWERPLATFORMTOOLS_PACPATH" connection show --name "<expected-conn-name>"
            found_conn_id=""
          fi
  
          if [ -n "$found_conn_id" ]; then
            echo "Found connection id for $logicalName -> $found_conn_id. Patching settings.json..."
            # Update settings.tmp.json: set .ConnectionReferences[i].ConnectionId = found_conn_id
            jq --arg id "$found_conn_id" --argjson idx "$i" \
               '.ConnectionReferences[$idx].ConnectionId = $id' "$TMP" > "${TMP}.2" && mv "${TMP}.2" "$TMP"
          else
            echo "WARNING: could not find connection id for connector '$connector_token' in target environment."
            echo "You may need to create the connection in the target environment, or update the script to match your naming."
          fi
        done
  
        # finalize patched settings.json
        mv "$TMP" "$SETTINGS_FILE"
        echo "Settings after patch:"
        cat "$SETTINGS_FILE"

# way2 of importing
#    - name: Import managed solution into TEST using patched settings
#      run: |
#        echo "Importing solution to TEST using patched settings.json..."
#        "$POWERPLATFORMTOOLS_PACPATH" solution import \
#          --path "${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}" \
#          --settings-file "${{ env.MANAGED_FOLDER }}/settings.json" \
#          --environment "${{ env.TEST_ENV_URL }}"




    - name: Import solution using pac CLI
      run: |
        "$POWERPLATFORMTOOLS_PACPATH" auth create \
          --applicationId "${{ env.AZURE_CLIENT_ID }}" \
          --clientSecret "${{ env.AZURE_CLIENT_SECRET }}" \
          --tenant "${{ env.AZURE_TENANT_ID }}" \
          --environment "${{ env.TEST_ENV_URL }}"
    
        "$POWERPLATFORMTOOLS_PACPATH" solution import \
          --path "${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}" \
          --settings-file "${{ env.MANAGED_FOLDER }}/settings.json" \
          --force-overwrite



    - name: Import managed solution to TEST (with settings)
      uses: microsoft/powerplatform-actions/import-solution@v1
      with:
        environment-url: ${{ env.TEST_ENV_URL }}
        
        # SPN authentication
        app-id: ${{ env.AZURE_CLIENT_ID }}
        client-secret: ${{ env.AZURE_CLIENT_SECRET }}
        tenant-id: ${{ env.AZURE_TENANT_ID }}
        
        # Solution package
        solution-file: ${{ env.MANAGED_FOLDER }}/${{ env.SOLUTION_ZIP_NAME }}
        
        # Deployment settings file
        deployment-settings-file: ${{ env.MANAGED_FOLDER }}/settings.json
        
        # Recommended flags
        async: true
        max-async-wait-time: 60
        force-overwrite: true
        publish-changes: true

    
